# Project_template

Это шаблон для решения проектной работы. Структура этого файла повторяет структуру заданий. Заполняйте его по мере работы над решением.

# Задание 1. Анализ и планирование



### 1. Описание функциональности монолитного приложения

**Управление отоплением:**

- Пользователи могут удалённо включать и выключать отопление в своих домах через веб-интерфейс.
- Система поддерживает прямое управление отоплением через отправку команд от сервера к датчикам.
- Каждое подключение требует выезда специалиста для настройки системы.

**Мониторинг температуры:**

- Пользователи могут просматривать текущую температуру в своих домах через веб-интерфейс.
- Система поддерживает получение данных о температуре через синхронные запросы от сервера к датчикам.
- Данные отображаются в реальном времени, но только для уже подключенных устройств.

### 2. Анализ архитектуры монолитного приложения

Характеристика текущего приложения:
- Язык программирования: Go
- База данных: PostgreSQL
- Архитектура: Монолитная – все компоненты (обработка запросов, бизнес-логика, доступ к данным) объединены в одном приложении.
- Взаимодействие: Синхронное, последовательная обработка запросов.
- Масштабируемость: Ограничена, так как нельзя масштабировать отдельные компоненты.
- Развертывание: Требует полной остановки приложения для обновлений.
- Подключение устройств: Только через специалистов, самостоятельное подключение пользователем невозможно.
- Текущий охват: 100 веб-клиентов и 100 модулей управления отоплением.

### 3. Определение доменов и границы контекстов

1. Домен «Управление устройствами»
   - Контекст: Самостоятельное подключение устройств пользователем, поддержка протоколов партнёров.
   - Процессы, реализуемые доменом: Регистрация, аутентификация, хранение метаданных устройств, управление состоянием подключения.
   - Сущности: Устройство, датчик, реле, ворота, камера.

2. Домен «Телеметрия и мониторинг»
   - Контекст: Мониторинг температуры, наблюдение за домом, история изменений.
   - Процессы, реализуемые доменом: Сбор, хранение, агрегация и предоставление данных с датчиков (температура, состояние устройств).
   - Сущности: Показания датчиков, метрики, журналы событий.

3. Домен «Управление сценариями»
   	- Контекст: Программирование системы пользователем под свои нужды.
	- Процессы, реализуемые доменом: Создание, выполнение и управление автоматическими сценариями (правилами) — например, «включить свет при движении».
 	- Сущности: Сценарий, правило, триггер, действие.

4. Домен «Пользователи и безопасность»
   	- Контекст: SaaS-модель, мультитенантность, самообслуживание.
	- Процессы, реализуемые доменом: Управление пользователями, аутентификация, авторизация, роли, разрешения.
	- Сущности: Пользователь, роль, сессия, токен.

5. Домен «Уведомления и события»
   	- Контекст: Оповещения о событиях, срабатывании сценариев, аномалиях.
	- Процессы, реализуемые доменом: Отправка уведомлений пользователям (email, push), обработка системных событий.
	- Сущности: Уведомление, шаблон, канал доставки.

6. Домен «Платежи и подписки»
   - Контекст: Продажа модульных комплектов, SaaS-модель.
   - Процессы, реализуемые доменом: Управление тарифами, подписками, оплатой, учётом использования.
   - Сущности: Подписка, транзакция, тариф, счёт.

7. Домен «Интеграция с внешними устройствами»
   - Контекст: Расширяемость экосистемы.
   - Процессы, реализуемые доменом: Поддержка протоколов взаимодействия с устройствами партнёров (Zigbee, Z-Wave, MQTT и др.).
   - Сущности: Адаптер протокола, драйвер устройства.

Ключевые домены для MVP:
Если говорить о MVP с управлением:
		- Отоплением
		- Освещением
		- Наблюдением
		- Воротами
Поэтому для MVP разработкуначать с доменов:
		- Управление устройствами
		- Телеметрия
		- Управление сценариями
		- Пользователи и безопасность
### **4. Проблемы монолитного решения**

1. Ограниченная масштабируемость
	- Только вертикальное масштабирование. Нельзя масштабировать отдельные модули (например, только управление освещением при высокой нагрузке).
	- Ресурсы расходуются неэффективно: даже если нагрузка только на одном функциональном модуле, приходится масштабировать весь монолит.
	- Не поддерживается геораспределение, что критично для обслуживания нескольких регионов, невозможность масштабировать географию продаж.

2. Сложность внедрения новых функций
	- Жёсткая связанность компонентов: изменение в одной части системы (например, добавление поддержки новых датчиков) требует пересборки и переразвёртывания всего приложения.
	- Долгий цикл разработки: из-за необходимости тестировать весь монолит даже при небольших изменениях.
	- Невозможно независимое развёртывание новых модулей (умный свет, ворота, камеры).

3. Низкая отказоустойчивость
	- Единая точка отказа: сбой в одном модуле (например, в работе с БД) приводит к падению всей системы.
	- Нет изоляции отказов: ошибка в новом модуле управления освещением может «повалить» и управление отоплением.
	- Сложное восстановление: при падении системы перезапускается всё приложение целиком, а не только проблемный компонент.

4. Проблемы с производительностью
	- Синхронная обработка запросов создаёт узкие места: долгий запрос к датчику блокирует обработку других запросов.
	- Отсутствие асинхронности: нет возможности фоновой обработки задач (например, сбор телеметрии, генерация отчётов).
	- Нет кэширования и оптимизированных хранилищ под разные типы данных.
	

### 5. Визуализация контекста системы — диаграмма С4

Добавьте сюда диаграмму контекста в модели C4.

Чтобы добавить ссылку в файл Readme.md, нужно использовать синтаксис Markdown. Это делают так:

```markdown
[Текст ссылки](URL)
```

Замените `Текст ссылки` текстом, который хотите использовать для ссылки. Вместо `URL` вставьте адрес, на который должна вести ссылка. Например:

```markdown
[Посетите Яндекс](https://ya.ru/)
```

# Задание 2. Проектирование микросервисной архитектуры

В этом задании вам нужно предоставить только диаграммы в модели C4. Мы не просим вас отдельно описывать получившиеся микросервисы и то, как вы определили взаимодействия между компонентами To-Be системы. Если вы правильно подготовите диаграммы C4, они и так это покажут.

**Диаграмма контейнеров (Containers)**

Добавьте диаграмму.

**Диаграмма компонентов (Components)**

Добавьте диаграмму для каждого из выделенных микросервисов.

**Диаграмма кода (Code)**

Добавьте одну диаграмму или несколько.

# Задание 3. Разработка ER-диаграммы

Добавьте сюда ER-диаграмму. Она должна отражать ключевые сущности системы, их атрибуты и тип связей между ними.

# Задание 4. Создание и документирование API

### 1. Тип API

Укажите, какой тип API вы будете использовать для взаимодействия микросервисов. Объясните своё решение.

### 2. Документация API

Здесь приложите ссылки на документацию API для микросервисов, которые вы спроектировали в первой части проектной работы. Для документирования используйте Swagger/OpenAPI или AsyncAPI.

# Задание 5. Работа с docker и docker-compose

Перейдите в apps.

Там находится приложение-монолит для работы с датчиками температуры. В README.md описано как запустить решение.

Вам нужно:

1) сделать простое приложение temperature-api на любом удобном для вас языке программирования, которое при запросе /temperature?location= будет отдавать рандомное значение температуры.

Locations - название комнаты, sensorId - идентификатор названия комнаты

```
	// If no location is provided, use a default based on sensor ID
	if location == "" {
		switch sensorID {
		case "1":
			location = "Living Room"
		case "2":
			location = "Bedroom"
		case "3":
			location = "Kitchen"
		default:
			location = "Unknown"
		}
	}

	// If no sensor ID is provided, generate one based on location
	if sensorID == "" {
		switch location {
		case "Living Room":
			sensorID = "1"
		case "Bedroom":
			sensorID = "2"
		case "Kitchen":
			sensorID = "3"
		default:
			sensorID = "0"
		}
	}
```

2) Приложение следует упаковать в Docker и добавить в docker-compose. Порт по умолчанию должен быть 8081

3) Кроме того для smart_home приложения требуется база данных - добавьте в docker-compose файл настройки для запуска postgres с указанием скрипта инициализации ./smart_home/init.sql

Для проверки можно использовать Postman коллекцию smarthome-api.postman_collection.json и вызвать:

- Create Sensor
- Get All Sensors

Должно при каждом вызове отображаться разное значение температуры

Ревьюер будет проверять точно так же.


# **Задание 6. Разработка MVP**

Необходимо создать новые микросервисы и обеспечить их интеграции с существующим монолитом для плавного перехода к микросервисной архитектуре. 

### **Что нужно сделать**

1. Создайте новые микросервисы для управления телеметрией и устройствами (с простейшей логикой), которые будут интегрированы с существующим монолитным приложением. Каждый микросервис на своем ООП языке.
2. Обеспечьте взаимодействие между микросервисами и монолитом (при желании с помощью брокера сообщений), чтобы постепенно перенести функциональность из монолита в микросервисы. 

В результате у вас должны быть созданы Dockerfiles и docker-compose для запуска микросервисов. 
